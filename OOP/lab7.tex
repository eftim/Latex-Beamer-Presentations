\documentclass[12pt,a4paper]{exam}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{ucs}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,bulgarian]{babel}
\usepackage{listings}
\usepackage{color}
\definecolor{lightgrey}{rgb}{0.9,0.9,0.9}
\usepackage[usenames,dvipsnames]{xcolor}
\input{code_style_labC.tex}

\begin{document}
\pagestyle{headandfoot}
\header{\textbf{ФИНКИ\\Објектно ориентирано
програмирање}}{}{\large{\textbf{Лабораториска вежба 6}}}
\headrule
\cfoot{Страна \thepage}
\begin{center}
\Large{\textbf{Наследување}}
\end{center}
\begin{questions}

\question
Да се напише класа \texttt{Employee}, со која ќе се опише вработени во една фирма. За
вработениот треба да се води евиденција за името на вработениот и коефициент на
плата (колку денари заработува по час). Дополнително да се напише функција \texttt{pay} за
пресметка на плата во завиност од одработените часа. 

Потоа од класата \texttt{Employee} да се
изведе класа \texttt{Manager}. Во класата \texttt{Manager} дополнително да се
чува информација за тоа дали менаџерот веќе бил исплатен  Да се преоптовари
функцијата \texttt{pay} на тој начин што ако, менџерот бил исплатен само да се
врати коефициентот на платата, во спротивно да се врати платата во зависност од
одработените часа.

\question
Да се напише класа \texttt{Pravoagolnik} која ќе го овозможи опишување на еден
правоаголник. Страните на правоаголникот треба да бидат приватни членови на
класата. Да се напише конструктор и деструктор, како и соодветни set и get
методи. Да се напише функција која ќе ја пресмета плоштината на правоаголникот.
Да се преоптоварат операторите $+, ==, <<, >>$. При тоа со $+$ операторот ќе се
овозможи собирање на соодветните страни на два правоаголници, а операторот $==$
ќе провери дали имаат исти соодветни страни. Со $<<$ и $>>$ ќе се овозможи
печатење и внесување на страните на правоаголникот, соодветно. 

Потоа од класата \texttt{Pravoagolnik} да се изведе класа \texttt{Kvadar}.
Класата \texttt{Kvadar} ќе има уште една страна како приватен член, \texttt{get,
set} методи и функција за пресметување на волумен. Да се преотовари функцијата
за пресметување на плоштина, што ќе ја пресмета плоштината на квадарот. Да се
преоптовари операторот $==$ што ќе провери дали два квадари се исти (имаат исти
соодветни страни). 

Да се напише main функција во која ќе се тестираат класите. Печатањето треба да
биде во следниот формат:
\begin{verbatim}
a = 1 b = 1
(за операторот << од правоаголник)
a = 1 b = 1 c = 1 
(за операторот << од квадар)
\end{verbatim} 

\question
Да се напише класа \texttt{Sportist}, којa ќе содржи:
\begin{itemize}
  \item име на спортистот (низа од 20 знаци),
  \item број на дрес.
\end{itemize}
Во класата да се дефинираат конструктор со влезни аргументи соодветни на
приватните променливи на класата, copy конструктор, деструктор, get и set
методи, функција за печатење на спортистот. 

Дополнително да се напише класа \texttt{Odbojkar}, која ќе наследува од класата
\texttt{Sportist} и во која дополнително ќе се чуваат информации за:
\begin{itemize}
  \item позиција на која игра (цел број од 1 до 6)
  \item дали е капитен (bool променлива).
\end{itemize}
Во класата да се дефинираат конструктор со влезни аргументи соодветни на
приватните променливи на класата, copy конструктор, деструктор, get и set
методи, функција за печатење на одбојкарот. Да се преоптовари операторот $==$ за
споредба на двајца одбојкари според нивниот дрес.

На крај да се напише класа \texttt{OdbojkarskiTim}, која ќе содржи:
\begin{itemize}
  \item име на тимот (низа од 30 знаци)
  \item низа од одбојкари (динамички алоцирана),
  \item број на одбојкари во тимот.
\end{itemize}
Во класата да се дефинираат default конструктор, конструктор со параметри што
одговараат на сите атрибути на класата, деструктор и функција за печатење на
целиот тим. Да се преоптовари операторот $+=$ за додавање на нов одбојкар
во тимот. Да се внимава дали неговиот дрес е веќе зафатен. Во спротивно да се
испечати соодветна порака. Покрај тоа, не треба да се дозволи додавање на втор
капитен на тимот, ако истиот веќе има капитен.

Да се напише main функција во која ќе се тестираат имплементираните функции во
класите.

\question
Да се дефинира класа \texttt{Licnost}, во која ќе се чуваат следниве информации:
\begin{itemize}
  \item име (низа од 20 знаци),
  \item матичен број (низа од 13 знаци).
\end{itemize}
Во рамките на класата да се дефинираат соодветен конструктор, деструктор, \texttt{get} и
\texttt{set} методи. 

Од оваа класа да се изведе класа \texttt{Avtor}, за која дополнително ќе се
чуваат следниве информации:
\begin{itemize}
  \item колку книги напишал,
  \item која му е најпозната книга.
\end{itemize}
Во рамките на класата да се дефинираат соодветен конструктор,
деструктор и да се преоптовари операторот $<<$ кој
ќе ги печати сите информации за авторот. 

Од класата \texttt{Licnost} да се изведе и класа \texttt{Rabotnik}, за кој
дополнително ќе се чува:
\begin{itemize}
  \item фирмата за која работи (низа од 50 знаци),
  \item број на работни часови (цел број),
  \item колку е платен за 1 работен час (цел број).
\end{itemize}
Во рамките на класата да се дефинираат конструктор со предефинирани вредности,
деструктор и функција која пресметува колку плата зема работникот.

Да се напише main функција во која ќе се тестираат имплементираните функции во
класите.

\question
Да се напише класа \texttt{Conv} која ќе служи за претворање на валути. Класата
треба да содржи информација за среден курс, конструктор со еден параметар и две
методи: \texttt{float pretvori(float)} и \texttt{float pretvoriObratno(float)}
кои ќе служат за претворање на валутата според дадениот курс и обратнo.
Функцијата \texttt{pretvori} го множи пренесениот број со средниот курс и го
враќа резултатот, а \texttt{pretvoriObratno} го дели пренесениот број со курсот
и го враќа резултатот. 

Да се напишат две класи кои ќе служат за претворање на валути од евра во денари
и обратно (со курс 61.5) и долари во денари и обратно (со курс 46.1). Истите да бидат
наследени од класата \texttt{Conv} и во целост да ги користат нејзините функционалности.

Да се направи класа \texttt{InterConv} која ќе се состои од два објекти од
класата \texttt{Conv}. Истата треба да содржи конструктор со два аргументи,
функција \texttt{pretvori} која ќе претвара вредност од странската валута од
првиот објект кон странската валута од вториот објект (пример евра во долари) и
функција \texttt{pretvoriObratno} која ќе ја врши обратната работа. 

main функција за тестирање:
\begin{lstlisting}
int main() {
    ConvEvro evr;
    ConvDolar dlr;
    Int br;
    cout << "Vnesi broj ";
    cin >> br;
    cout << br << " evra= " << evr.pretvori(br) << " denari" << endl;
    cout << br << " denari = " << evr.pretvoriObratno(br) << " evra" << endl;
    cout << br << " dolari = " << dlr.pretvori(br) << " denari" << endl;
    cout << br << " denari = " << dlr.pretvoriObratno(br) << " dolari" << endl;
    Conv cv1(61.5), cv2(46.1);
    InterConv inCv(cv1, cv2);
    cout << br << " evra = " << inCv.pretvori(br) << " dolari" << endl;
    cout << br << " dolari = " << inCv.pretvoriObratno(br) << "evra" << endl;
    return 0;
}
\end{lstlisting}

\question
Да се напише класа \texttt{NumberGenerator} која што ќе има задача да создава
броеви во одредено поле според одредено правило. Во рамките на класата треба да се чува
информација за степен (int). Да се дефинира конструктор со еден аргумент и
функција \texttt{popolni} која прима четири аргументи: покажувач кон полето од
целобројни вредности кое треба да се пополни, почетна вредност, стартна позиција
за пополнување и крајна позиција за пополнување. Пополнувањето се врши на
следниов начин: \\
нека е дадено поле од 30 елементи. Степенот е 2 а функцијата е повикана со
аргументите (pole, 3, 22, 26). Со овој повик полето треба да се промени на
следниов начин:\\
\[
\begin{array}{l}
Pole[22]=3^2=9\\
Pole[23]=4^2=16\\
Pole[24]=5^2=25\\
Pole[25]=6^2=36\\
Pole[26]=7^2=49
\end{array}
\]

Од оваа класа да се наследат три класи \texttt{LinearGenerator},
\texttt{KvadratGenerator}, \texttt{KubGenerator} кои што ќе имаат степени 1, 2 и
3 соодветно. Дополнително за класата \texttt{KubGenerator} да се преоптовари
операторот $<<$ со што на излез ќе се прикажува историјата на работата на
објектот т.е. кои се броеви се генерирани од истиот без разлика дали станува
збор за едно или повеќе полиња и дали броевите се повторуваат. 
Пример:
\begin{verbatim}
KubGenerator kGen; kGen.Popolni(pole, 2, 22, 23); //pole[22]=8, pole[23]=27
kGen.Popolni(pole, 3, 24, 25); //pole[24]=27, pole[25]=64
kGen.Popolni(pole, 2, 26, 27); //pole[26]=8, pole[27]=27
cout <<kGen;
//излез: 8 27 27 64 8 27
\end{verbatim}
Совет: за да се овозможи ова, во рамките на класата KubGenerator ќе се чува поле кое ќе
се пополнува динамички. Елементите во него ќе се полната во рамките на
функцијата \texttt{popolni}. 

main функција за тестирање:
\begin{lstlisting}
int main() {
    int pole[5] { 0 };
    for (int i = 0; i < 5; i++)
        pole[i] = 0;
    for (int i = 0; i < 5; ++i)
        cout << "pole[" << i << "]=" << pole[i] << endl;
    NumberGenerator gn(2);
    gn.popolni(pole, 3, 1, 3);
    for (int i = 0; i < 5; ++i)
        cout << "pole[" << i << "]=" << pole[i] << endl;
    LinearGenerator lnGen;
    lnGen.popolni(pole, 5, 0, 2);
    for (int i = 0; i < 5; ++i)
        cout << "pole[" << i << "]=" << pole[i] << endl;
    KvadratGenerator kvGen;
    kvGen.popolni(pole, 10, 3, 4);
    for (int i = 0; i < 5; ++i)
        cout << "pole[" << i << "]=" << pole[i] << endl;
    KubGenerator kbGen;
    kbGen.popolni(pole, 3, 0, 3);
    kbGen.popolni(pole, 2, 1, 2);
    kbGen.popolni(pole, 6, 3, 4);
    for (int i = 0; i < 5; ++i)
        cout << "pole[" << i << "]=" << pole[i] << endl;
    cout << kbGen << endl;
    return 0;
}
\end{lstlisting}

\end{questions}
\end{document}